import { Point, GcodeSettings, CoordinateTransformer } from "./types";
import { CoordinateTransformerImpl } from "./coordinate-transformer";
import { ShapeGeneratorFactory } from "./generators/shape-generator-factory";
import {
  CommentCommand,
  SetupCommand,
  LaserControlCommand,
  EndProgramCommand,
} from "./commands";
import { GcodeBuilderImpl } from "./builder";

export class GcodeGenerator {
  private coordinateTransformer: CoordinateTransformer;
  private mainBuilder: GcodeBuilderImpl;

  constructor() {
    this.coordinateTransformer = new CoordinateTransformerImpl();
    this.mainBuilder = new GcodeBuilderImpl();

    // Set the node processor for compound shapes
    ShapeGeneratorFactory.setNodeProcessor(
      (node: SceneNode, settings: GcodeSettings) =>
        this.generateForNode(node, settings)
    );
  }

  generateGcode(
    nodes: readonly SceneNode[],
    feedRate: number = 1000,
    rapidFeedRate: number = 3000,
    laserPower: number = 255
  ): string {
    const settings: GcodeSettings = { feedRate, rapidFeedRate, laserPower };

    this.mainBuilder.reset();

    // Add header comments and setup
    this.addHeader(nodes, settings);

    // Process each selected node
    for (const node of nodes) {
      const gcode = this.generateForNode(node, settings);
      this.mainBuilder
        .addComment("")
        .addComment(`Processing node: ${node.name || "Unnamed"}`);
      // Add the generated gcode directly since it's already built
      this.mainBuilder.addCommand({ execute: () => gcode });
    }

    // Add footer
    this.addFooter();

    return this.mainBuilder.build();
  }

  private generateForNode(node: SceneNode, settings: GcodeSettings): string {
    const generator = ShapeGeneratorFactory.createGenerator(node.type);
    const globalPos = this.coordinateTransformer.getGlobalCoordinates(node);

    return generator.generate(node, globalPos, settings);
  }

  private addHeader(
    nodes: readonly SceneNode[],
    settings: GcodeSettings
  ): void {
    this.mainBuilder
      .addComment("Generated by Figma to G-code Plugin")
      .addComment(`Date: ${new Date().toISOString()}`)
      .addComment(`Page: ${figma.currentPage.name}`)
      .addComment(`Selected objects: ${nodes.length}`)
      .addComment(`Feed Rate: ${settings.feedRate} mm/min`)
      .addComment(`Rapid Feed Rate: ${settings.rapidFeedRate} mm/min`)
      .addComment(`Laser Power: ${settings.laserPower} (S parameter)`)
      .addComment("")
      .addCommand(
        new SetupCommand(
          settings.feedRate,
          settings.rapidFeedRate,
          settings.laserPower
        )
      )
      .addCommand(new LaserControlCommand(true, true))
      .addComment("");
  }

  private addFooter(): void {
    this.mainBuilder
      .addComment("")
      .addComment("End of G-code")
      .addCommand(new LaserControlCommand(false, true))
      .addCommand(new EndProgramCommand());
  }

  generateFilename(nodes: readonly SceneNode[]): string {
    if (nodes.length === 0) {
      return "gcode";
    }

    // Use the first node's name as base filename
    let baseName = nodes[0].name || "untitled";

    // Clean the name for use as filename (remove invalid characters)
    baseName = baseName.replace(/[<>:"/\\|?*]/g, "_");

    // Add count if multiple nodes
    if (nodes.length > 1) {
      baseName += `_and_${nodes.length - 1}_more`;
    }

    // Add timestamp
    const timestamp = new Date()
      .toISOString()
      .replace(/[:.]/g, "-")
      .slice(0, -5);

    return `${baseName}_${timestamp}`;
  }
}
